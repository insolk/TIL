- 암호 시스템

```

                         암호화 
      +--------------------->----------------------+
      |                                            |
평문(Plain text) <=======> 알고리즘 <=======> 암호문(Cipher text)
      |                        +                   |  
      |                     키(key)                |
      |                                            |
      +---------------------<----------------------+
                         복호화

```

- 키 구성에 따라서 대칭키 암호화 방식과 비대칭 암호화 방식으로 구분이 가능



- 대칭키 : 암호화 과정에 사용된 키와 복호화 과정에 사용된 키가 동일
- = 유일키
- = 비밀키 ⇒ "비밀키 암호화 방식"
- = 관용 암호화 방식
- 단점: 키 관리 및 분배가 어렵다.

```
 CIPHER(data,keyA)
송신자 ---------------+---------------> 수신자A
 data                 |                 CIPHER(data,keyA) → 복호화에 사용할 key를 가지고 있지 않음 ⇒ 키 분배 문제
 keyA                 |
           도청 및 훔쳐보기가 가능
                      |
                      | 
 keyB  ---------------+---------------> 수신자B 
~~~~~~
수신자 많아지면(=통신 대상이 많아지면) 관리해야할 키가 증가 ⇒ 키 관리 문제

```



- 비대칭키 : 암호화 과정에 사용된 키와 복호화 과정에 사용된 키가 상이
- 개인키와 공개키로 구성된 키 쌍을 생성 ← 유일키의 개념이 깨짐
- (개인키는 외부에 오픈되지 않고,) 공개키는 외부에 오픈해도 무관 ← 비밀키의 개념이 깨짐 ⇒ "공개키 암호화 방식"
- 개인키로 암호화한 것은 공개키로 복호화할 수 있고, 공개키로 암호화한 것은 개인키로 복호화할 수 있음



```
(1) 키 쌍을 생성
송신자 -------------------------------> 수신자A
SndPriKey                               RcvPriKey 
SndPubKey                               RcvPubKey 

(2) 공개키를 공개키 저장소에 오픈 → 누구나가 참조 가능 ⇒ 키 분배의 문제가 해결
    모든 사용자는 자신의 개인키만 안전하게 보관 ⇒ 키 관리의 문제가 해결
          [ SndPubKey, RcvPubKey ]
송신자 -------------------------------> 수신자A
SndPriKey                               RcvPriKey 

```

- 송신자가 수신자A만 볼 수 있도록 데이터를 전달하는 방법 ⇒ 기밀성 서비스를 구현

- (1) 수신자A의 공개키를 취득

- (2) 수신자A의 공개키로 데이터를 암호화 

- (3) 암호화된 데이터를 전달

- (4) 수신자A는 자신의 개인키로 암호화된 데이터를 복호화

  

- 원본증명, 부인방지, 인증 등의 서비스를 구현

- (1) 송신자가 본의 개인키로 암호화해서 전달 ⇒ "서명한다"

- (2) 암호화된 데이터와 암호화된 데이터를 복호화하는데 필요한 공개키는 누구나 취득이 가능

- (3) 암호화된 데이터가 송신자의 공개키로 복호화된다는 것   

- ⇒ 송신자의 개인키로 암화된 것 = 암호화된 데이터가 송신자가 만들 것이 확실  

- ⇒ "서명검증한다"

- aws 엑세스 키, 외부에 유출되지 않도록 유의, csv로 저장하여 잊어 버리진 말아야 함